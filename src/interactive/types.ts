/**
 * Interactive CLI Session Types
 *
 * Types for managing interactive sessions with CLI tools where
 * pk-puzldai acts as the "user" responding to prompts.
 */

import type { AgentName } from '../executor/types';

/**
 * State of an interactive session
 */
export type InteractiveSessionState =
  | 'initializing'
  | 'running'
  | 'waiting_for_input'
  | 'responding'
  | 'completed'
  | 'failed'
  | 'timeout';

/**
 * A detected prompt from the CLI tool
 */
export interface DetectedPrompt {
  /** Raw text of the prompt */
  text: string;
  /** Type of prompt detected */
  type: 'question' | 'confirmation' | 'input' | 'verification' | 'choice' | 'unknown';
  /** Available choices if it's a choice prompt */
  choices?: string[];
  /** Whether this appears to be a terminal/final prompt */
  isFinal?: boolean;
  /** Timestamp when detected */
  timestamp: number;
}

/**
 * Response generated by the AI responder
 */
export interface GeneratedResponse {
  /** The response text to send */
  response: string;
  /** Reasoning for this response */
  reasoning?: string;
  /** Whether this should end the session */
  shouldEnd?: boolean;
  /** Confidence in this response (0-1) */
  confidence?: number;
}

/**
 * Configuration for an interactive session
 */
export interface InteractiveSessionConfig {
  /** The CLI tool/adapter to use */
  agent: AgentName;
  /** Command or prompt to start the session */
  initialPrompt: string;
  /** The goal/plan context for the AI responder */
  planContext: string;
  /** Maximum number of interactions before timeout */
  maxInteractions?: number;
  /** Timeout for waiting for output (ms) */
  outputTimeout?: number;
  /** Timeout for the entire session (ms) */
  sessionTimeout?: number;
  /** Agent to use for generating responses */
  responderAgent?: AgentName;
  /** Custom prompt patterns to detect */
  promptPatterns?: RegExp[];
  /** Callback for each interaction */
  onInteraction?: (prompt: DetectedPrompt, response: GeneratedResponse) => void;
  /** Callback for output chunks */
  onOutput?: (chunk: string) => void;
  /** Working directory for the CLI */
  cwd?: string;
  /** Environment variables */
  env?: Record<string, string>;
  /** Model to use for the CLI tool */
  model?: string;
}

/**
 * Result of an interactive session
 */
export interface InteractiveSessionResult {
  /** Whether the session completed successfully */
  success: boolean;
  /** Final state of the session */
  state: InteractiveSessionState;
  /** All output from the session */
  output: string;
  /** Number of interactions that occurred */
  interactions: number;
  /** Duration in milliseconds */
  duration: number;
  /** Error message if failed */
  error?: string;
  /** History of prompts and responses */
  history: Array<{
    prompt: DetectedPrompt;
    response: GeneratedResponse;
  }>;
}

/**
 * Options for the AI responder
 */
export interface ResponderOptions {
  /** The goal/plan context */
  planContext: string;
  /** The detected prompt to respond to */
  prompt: DetectedPrompt;
  /** Previous interactions for context */
  history?: Array<{
    prompt: DetectedPrompt;
    response: GeneratedResponse;
  }>;
  /** Full output buffer for additional context */
  outputBuffer?: string;
  /** Agent to use for responding */
  agent?: AgentName;
}

/**
 * CLI tool configuration for interactive mode
 */
export interface CLIToolConfig {
  /** Command to run */
  command: string;
  /** Arguments for interactive mode */
  interactiveArgs: string[];
  /** Prompt patterns that indicate waiting for input */
  promptPatterns: RegExp[];
  /** Pattern that indicates session end */
  endPatterns: RegExp[];
  /** How to format the response before sending */
  formatResponse?: (response: string) => string;
}

/**
 * Built-in CLI tool configurations
 */
export const CLI_TOOL_CONFIGS: Record<string, CLIToolConfig> = {
  gemini: {
    command: 'gemini',
    interactiveArgs: ['-i'],
    promptPatterns: [
      /^>\s*$/m,                    // Simple prompt
      /^\[.*\]\s*>\s*$/m,           // Bracketed prompt
      /\?\s*$/m,                    // Question ending
      /:\s*$/m,                     // Colon prompt
      /\(y\/n\)\s*$/im,             // Yes/no prompt
      /\[Y\/n\]\s*$/im,             // Default yes prompt
      /\[y\/N\]\s*$/im,             // Default no prompt
    ],
    endPatterns: [
      /goodbye/i,
      /session ended/i,
      /^exit$/im,
    ],
  },
  claude: {
    command: 'claude',
    interactiveArgs: [],  // Claude interactive mode is default (no -p flag)
    promptPatterns: [
      /^>\s*$/m,
      /^\[.*\]\s*>\s*$/m,
      /\?\s*$/m,
      /:\s*$/m,
      /\(y\/n\)\s*$/im,
    ],
    endPatterns: [
      /goodbye/i,
      /session ended/i,
    ],
  },
  codex: {
    command: 'codex',
    interactiveArgs: [],  // Codex interactive mode is default (not exec)
    promptPatterns: [
      /^>\s*$/m,
      />>>\s*$/m,
      /\?\s*$/m,
    ],
    endPatterns: [
      /session complete/i,
      /goodbye/i,
    ],
  },
  ollama: {
    command: 'ollama',
    interactiveArgs: ['run'],
    promptPatterns: [
      /^>>>\s*/m,
    ],
    endPatterns: [
      /^\/bye\s*$/im,
    ],
    formatResponse: (r) => r + '\n',
  },
};
